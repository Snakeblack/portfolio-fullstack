---
---

<script>  // Define a more specific Window type for this script's context
  interface CustomWindow extends Window {
    toggleThemeAndIcons?: () => void;
    updateThemeIcons?: (isDark: boolean) => void;
    lastScrollY?: number;
  }
  // Tell TypeScript to use this custom type for 'window' in this module
  declare var window: CustomWindow;
  import { gsap } from "gsap";
  import { ScrollTrigger } from "gsap/ScrollTrigger";

  gsap.registerPlugin(ScrollTrigger);

  console.log('GSAP loaded:', typeof gsap);
  console.log('ScrollTrigger loaded:', typeof ScrollTrigger);

  // Attempt to prevent scroll jump on refresh
  if ('scrollRestoration' in history) {
    history.scrollRestoration = 'manual';
  }  // Mobile detection
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
  // Enhanced scroll detection variables - declared globally for access in all functions
  let scrollTimeout: ReturnType<typeof setTimeout>;
  let isScrollbarDrag = false;
  let lastScrollTime = 0;
  let lastScrollPosition = 0;
  let animatedElementsSet = new Set(); // Track which elements have been animated
  let scrollVelocityHistory: number[] = []; // Track scroll velocity pattern
  let isWheelScrolling = false;
  let wheelTimeout: ReturnType<typeof setTimeout>;
  let consecutiveFastScrolls = 0;

  function applyTheme(theme: string) {
    if (theme === 'dark') {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  }

  // FunciÃ³n para alternar el tema y actualizar iconos
  window.toggleThemeAndIcons = function() {
    const currentTheme = localStorage.getItem('color-theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
    
    localStorage.setItem('color-theme', newTheme);
    applyTheme(newTheme);
    
    if (window.updateThemeIcons) {
      window.updateThemeIcons(newTheme === 'dark');
    }
  }  // Function to initialize ScrollTrigger animations
  function initScrollAnimations() {
    console.log('Initializing scroll animations...');
    
    // Clear any existing ScrollTriggers first
    ScrollTrigger.getAll().forEach(trigger => trigger.kill());
    
    // Configure ScrollTrigger for better scrollbar compatibility
    ScrollTrigger.config({
      autoRefreshEvents: "visibilitychange,DOMContentLoaded,load,resize",
      ignoreMobileResize: true
    });
    
    // GSAP ScrollTrigger animations with proper fade-up effect
    const animatedElements = document.querySelectorAll('.scroll-animate, .scroll-animate-fast, .title-animate');
    console.log('Found animated elements:', animatedElements.length);

    animatedElements.forEach((el, index) => {
      const htmlEl = el as HTMLElement;
      const isFast = el.classList.contains('scroll-animate-fast');
      const isTitle = el.classList.contains('title-animate');
      const isFooter = el.tagName.toLowerCase() === 'footer' || el.closest('footer');
      
      // Clear any CSS transitions that might interfere
      htmlEl.style.transition = 'none';
      htmlEl.style.transitionDelay = '0s';
      htmlEl.style.willChange = 'transform, opacity'; // Optimize for animations
      
      // Set initial state with GSAP - more conservative values
      gsap.set(el, {
        opacity: 0,
        y: isFast ? 15 : isTitle ? 10 : 20, // Reduced distances for smoother animations
        scale: 0.99, // More subtle scale
        visibility: 'visible',
        clearProps: 'transition,transition-delay'
      });

      // Create the animation with simpler, more reliable settings
      gsap.to(el, {
        opacity: 1,
        y: 0,
        scale: 1,
        duration: isFast ? 0.5 : isTitle ? 0.7 : 0.9, // Slightly faster
        ease: "power1.out", // Gentler easing
        scrollTrigger: {
          trigger: el,
          start: isFooter ? "top 88%" : "top 80%", // Adjusted footer trigger point
          toggleActions: "play none none none", // No reverse to prevent flickering
          once: true, // Animate only once
          markers: false,
          fastScrollEnd: true,
          onEnter: () => {
            animatedElementsSet.add(el);
            console.log('Element animated:', el.className);
          }
        }
      });
    });    // Stagger animations for containers - simplified
    const staggerContainers = document.querySelectorAll('.stagger-children');
    console.log('Found stagger containers:', staggerContainers.length);

    staggerContainers.forEach((container, index) => {
      const children = Array.from(container.children);
      
      if (children.length > 0) {
        // Clear CSS transitions for children
        children.forEach(child => {
          const htmlChild = child as HTMLElement;
          htmlChild.style.transition = 'none';
          htmlChild.style.transitionDelay = '0s';
        });
        
        // Set initial state for children
        gsap.set(children, {
          opacity: 0,
          y: 15, // Reduced movement
          scale: 0.99,
          visibility: 'visible',
          clearProps: 'transition,transition-delay'
        });
        
        gsap.to(children, {
          opacity: 1,
          y: 0,
          scale: 1,
          duration: 0.6, // Faster duration
          stagger: 0.05, // Reduced stagger
          ease: "power1.out", // Simpler easing
          scrollTrigger: {
            trigger: container,
            start: "top 85%",
            toggleActions: "play none none none", // No reverse
            once: true // Only animate once
          }
        });
      }
    });    // Refresh ScrollTrigger after setup
    ScrollTrigger.refresh();
    
    console.log('ScrollTrigger initialized and refreshed');
  }
  document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM Content Loaded - Initializing scripts...');
    
    // Theme initialization
    const savedTheme = localStorage.getItem('color-theme');
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    let currentTheme = 'light';
    if (savedTheme) {
      currentTheme = savedTheme;
    } else if (prefersDark) {
      currentTheme = 'dark';
    }
    applyTheme(currentTheme); 
    localStorage.setItem('color-theme', currentTheme);

    setTimeout(() => {
      if (window.updateThemeIcons) {
        window.updateThemeIcons(currentTheme === 'dark');
      } else {
        console.error("[CommonScripts] updateThemeIcons function not found at initial call time.");
      }
    }, 0);    // Desplazamiento suave para enlaces internos
    document.querySelectorAll<HTMLAnchorElement>('a[href^="#"]').forEach((anchor: HTMLAnchorElement) => {
      anchor.addEventListener('click', function (this: HTMLAnchorElement, e: MouseEvent) { 
        e.preventDefault();
        const hrefAttribute: string | null = this.getAttribute('href');
        if (hrefAttribute) {
          const target: Element | null = document.querySelector(hrefAttribute);
          if (target) {
            target.scrollIntoView({
              behavior: 'smooth',
              block: 'start'
            });
          }
        }
      });
    });    // Initialize animations directly without test animation
    setTimeout(() => {
      initScrollAnimations();
    }, 100);
  });

  // Detect wheel scrolling to differentiate from scrollbar dragging
  window.addEventListener('wheel', () => {
    isWheelScrolling = true;
    clearTimeout(wheelTimeout);
    wheelTimeout = setTimeout(() => {
      isWheelScrolling = false;
    }, 150);
  }, { passive: true });  // Function to check and show visible elements
  function checkVisibleElements() {
    const allAnimatedElements = document.querySelectorAll('.scroll-animate, .scroll-animate-fast, .title-animate');
    const windowHeight = window.innerHeight;
    
    allAnimatedElements.forEach(el => {
      // Skip if element was already animated
      if (animatedElementsSet.has(el)) {
        return;
      }
      
      const rect = el.getBoundingClientRect();
      const isInViewport = rect.top < windowHeight * 0.9 && rect.bottom > -50;
      const currentOpacity = parseFloat(window.getComputedStyle(el).opacity);
      
      // Only animate if element is clearly hidden (opacity < 0.1) and in viewport
      if (isInViewport && currentOpacity < 0.1) {
        console.log('Manual check - showing element:', el);
        animatedElementsSet.add(el); // Mark as animated
        
        // Kill any existing animations on this element to prevent conflicts
        gsap.killTweensOf(el);
        
        gsap.to(el, {
          opacity: 1,
          y: 0,
          scale: 1,
          duration: 0.8,
          ease: "power1.out",
          overwrite: "auto", // Prevent conflicting animations
          onComplete: () => {
            console.log('Manual animation completed for:', el);
          }
        });
      }
    });
  }  // Function to force show all visible elements (for scrollbar usage)
  function forceShowVisibleElements() {
    const allAnimatedElements = document.querySelectorAll('.scroll-animate, .scroll-animate-fast, .title-animate');
    const windowHeight = window.innerHeight;
    let forcedCount = 0;

    allAnimatedElements.forEach(el => {
      const htmlEl = el as HTMLElement;
      const rect = el.getBoundingClientRect();
      // Very generous viewport check for scrollbar dragging
      const isInViewport = rect.top < windowHeight * 1.2 && rect.bottom > -windowHeight * 0.5;
      const currentOpacity = parseFloat(window.getComputedStyle(el).opacity);

      // Force show any element in viewport that isn't fully visible
      if (isInViewport && currentOpacity < 0.95) {
        console.log('Force showing element due to scrollbar/atBottom:', htmlEl.className, htmlEl.id || htmlEl.tagName);
        animatedElementsSet.add(el);
        forcedCount++;

        // Kill any existing animations to prevent conflicts
        gsap.killTweensOf(el);

        gsap.to(el, {
          opacity: 1,
          y: 0,
          scale: 1,
          duration: 0.6,
          ease: "power1.out",
          overwrite: "auto",
          force3D: true,
          onComplete: () => {
            console.log('Forced animation completed for:', htmlEl.className, htmlEl.id || htmlEl.tagName);
          }
        });
      }
    });
    
    console.log(`ForceShowVisibleElements completed. Forced ${forcedCount} elements.`);
  }
  // Aggressive function specifically for bottom elements
  function forceShowBottomElements() {
    const currentY = window.pageYOffset;
    const windowHeight = window.innerHeight;
    const documentHeight = document.documentElement.scrollHeight;
    const distanceFromBottom = documentHeight - currentY - windowHeight;
    
    // If we're within 400px of the bottom, force show ALL remaining hidden elements
    if (distanceFromBottom < 400) {
      const allAnimatedElements = document.querySelectorAll('.scroll-animate, .scroll-animate-fast, .title-animate');
      let bottomForcedCount = 0;
      
      allAnimatedElements.forEach(el => {
        const currentOpacity = parseFloat(window.getComputedStyle(el).opacity);
        
        if (currentOpacity < 0.95) {
          const htmlEl = el as HTMLElement;
          console.log('Force showing bottom element:', htmlEl.className, htmlEl.id || htmlEl.tagName);
          animatedElementsSet.add(el);
          bottomForcedCount++;
          
          gsap.killTweensOf(el);
          gsap.to(el, {
            opacity: 1,
            y: 0,
            scale: 1,
            duration: 0.8,
            ease: "power2.out",
            overwrite: "auto",
            force3D: true
          });
        }
      });
      
      console.log(`ForceShowBottomElements completed. Forced ${bottomForcedCount} elements.`);
    }
  }

  // Super aggressive function for end of page - shows ALL hidden elements regardless of position
  function forceShowAllRemainingElements() {
    const allAnimatedElements = document.querySelectorAll('.scroll-animate, .scroll-animate-fast, .title-animate');
    let remainingForcedCount = 0;
    
    console.log('FORCE SHOWING ALL REMAINING ELEMENTS');
    
    allAnimatedElements.forEach(el => {
      const currentOpacity = parseFloat(window.getComputedStyle(el).opacity);
      
      if (currentOpacity < 0.9) {
        const htmlEl = el as HTMLElement;
        console.log('Force showing remaining element:', htmlEl.className, htmlEl.id || htmlEl.tagName);
        animatedElementsSet.add(el);
        remainingForcedCount++;
        
        gsap.killTweensOf(el);
        gsap.to(el, {
          opacity: 1,
          y: 0,
          scale: 1,
          duration: 1.0,
          ease: "power2.out",
          overwrite: "auto",
          force3D: true,
          onComplete: () => {
            console.log('Completed forced animation for:', htmlEl.className);
          }
        });
      }
    });
    
    console.log(`ForceShowAllRemainingElements completed. Forced ${remainingForcedCount} elements.`);
  }

  // Function to clean up incomplete animations
  function cleanupIncompleteAnimations() {
    const allAnimatedElements = document.querySelectorAll('.scroll-animate, .scroll-animate-fast, .title-animate');
    const windowHeight = window.innerHeight;
    
    allAnimatedElements.forEach(el => {
      const rect = el.getBoundingClientRect();
      const isInViewport = rect.top < windowHeight && rect.bottom > 0;
      const currentOpacity = parseFloat(window.getComputedStyle(el).opacity);
      
      // If element is in viewport but has partial opacity (stuck animation)
      if (isInViewport && currentOpacity > 0 && currentOpacity < 0.9) {
        console.log('Cleaning up incomplete animation for:', el);
        animatedElementsSet.add(el);
        
        gsap.killTweensOf(el);
        gsap.to(el, {
          opacity: 1,
          y: 0,
          scale: 1,
          duration: 0.5,
          ease: "power1.out",
          overwrite: "auto"
        });
      }
    });
  }// Enhanced scroll handling with improved scrollbar detection
  window.addEventListener('scroll', () => {
    const currentTime = Date.now();
    const currentScrollY = window.pageYOffset;
    const scrollDelta = Math.abs(currentScrollY - lastScrollPosition);
    const timeDelta = currentTime - lastScrollTime;
    
    // Calculate scroll velocity
    const velocity = timeDelta > 0 ? scrollDelta / timeDelta : 0;
    
    // Add to velocity history (keep last 5 measurements)
    scrollVelocityHistory.push(velocity);
    if (scrollVelocityHistory.length > 5) {
      scrollVelocityHistory.shift();
    }
    
    // Multiple detection methods for scrollbar dragging
    const isLargeJump = scrollDelta > 100 && timeDelta < 50; // Original method
    const isVeryLargeJump = scrollDelta > 200; // Very large movement
    const isHighVelocity = velocity > 3; // High velocity scroll
    const isNotWheelScroll = !isWheelScrolling; // Not using mouse wheel
    
    // Enhanced detection: large movement without wheel OR very large movement OR high velocity pattern
    if ((isLargeJump && isNotWheelScroll) || isVeryLargeJump || (isHighVelocity && isNotWheelScroll)) {
      isScrollbarDrag = true;
      consecutiveFastScrolls++;
      console.log('Scrollbar drag detected - method:', 
        isLargeJump && isNotWheelScroll ? 'large+nowheel' : 
        isVeryLargeJump ? 'very-large' : 'high-velocity',
        'delta:', scrollDelta, 'time:', timeDelta, 'velocity:', velocity.toFixed(2));
    } else {
      // Reset consecutive count if scrolling normally
      if (velocity < 1) {
        consecutiveFastScrolls = 0;
      }
    }
    
    lastScrollPosition = currentScrollY;
    lastScrollTime = currentTime;
      clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => {
      const currentY = window.pageYOffset;
      
      // Calculate average velocity from history
      const averageVelocity = scrollVelocityHistory.length > 0 
        ? scrollVelocityHistory.reduce((sum, v) => sum + v, 0) / scrollVelocityHistory.length 
        : 0;      // Multiple conditions for triggering force show
      const atBottom = (document.documentElement.scrollHeight - currentY - window.innerHeight) < 150; // Increased threshold
      const nearBottom = (document.documentElement.scrollHeight - currentY - window.innerHeight) < 300; // Even more generous
      const veryNearBottom = (document.documentElement.scrollHeight - currentY - window.innerHeight) < 50; // Very close
      
      // Enhanced scrollbar detection
      const hadScrollbarActivity = isScrollbarDrag || consecutiveFastScrolls >= 2;
      const hasHighVelocity = averageVelocity > 2.0;
      
      // Trigger force show in multiple scenarios
      if (isScrollbarDrag || atBottom || nearBottom || (hasHighVelocity && !isWheelScrolling)) {
        console.log(`Scroll timeout triggered: isScrollbarDrag=${isScrollbarDrag}, atBottom=${atBottom}, nearBottom=${nearBottom}, hasHighVelocity=${hasHighVelocity}`);
        forceShowVisibleElements();
        forceShowBottomElements(); // Additional aggressive check for bottom elements
        ScrollTrigger.refresh(true);
      }
      
      // Super aggressive check when very close to bottom
      if (veryNearBottom) {
        console.log('Very close to bottom - showing ALL remaining elements');
        forceShowAllRemainingElements();
      }
      
      // Always check visible elements periodically
      checkVisibleElements();

      // Specific aggressive check for footer and bottom sections
      if (currentY + window.innerHeight >= document.documentElement.scrollHeight - 200) {
        console.log('Very close to bottom - triggering aggressive element show');
        forceShowBottomElements();
      }      // Specific logic for footer if needed (example, could be part of forceShowVisibleElements
      if (currentY + window.innerHeight >= document.documentElement.scrollHeight - 100) {
        const footer = document.querySelector('footer');
        if (footer && !animatedElementsSet.has(footer)) {
          const footerOpacity = parseFloat(window.getComputedStyle(footer).opacity);
          if (footerOpacity < 0.5) {
            console.log('Near bottom - showing footer');
            animatedElementsSet.add(footer);
            gsap.to(footer, {
              opacity: 1,
              y: 0,
              scale: 1,
              duration: 0.5,
              ease: "power1.out"
            });
          }
        }
      }    }, 30); // Reduced timeout for maximum responsiveness
  }, { passive: true });
  // Additional scroll end detection for maximum reliability
  let scrollEndTimeout: ReturnType<typeof setTimeout>;
  window.addEventListener('scroll', () => {
    clearTimeout(scrollEndTimeout);
    scrollEndTimeout = setTimeout(() => {
      // When scroll definitely ends, ensure all visible elements are shown
      console.log('Scroll definitely ended - final check');
      checkVisibleElements();
      forceShowBottomElements();
      
      // Extra aggressive check for bottom of page
      const currentY = window.pageYOffset;
      const distanceFromBottom = document.documentElement.scrollHeight - currentY - window.innerHeight;
      if (distanceFromBottom < 100) {
        console.log('Scroll ended very close to bottom - forcing all remaining elements');
        forceShowAllRemainingElements();
      }
    }, 200);
  }, { passive: true });// Window load event
  window.addEventListener('load', () => {
    console.log('Window loaded - refreshing ScrollTrigger...');
    setTimeout(() => {
      ScrollTrigger.refresh();
      checkVisibleElements(); // Initial check after load
      
      // Clean up any incomplete animations after a short delay
      setTimeout(() => {
        cleanupIncompleteAnimations();
      }, 1000);
    }, 200);
  });
  // Fallback check every 3 seconds to catch any missed elements (less frequent)
  setInterval(() => {
    // Only run if not currently scrolling and after significant time has passed
    if (!isScrollbarDrag && !isWheelScrolling) {
      const currentScrollY = window.pageYOffset;
      const timeSinceLastScroll = Date.now() - lastScrollTime;
      
      // If it's been at least 2 seconds since last scroll, check for missed elements
      if (timeSinceLastScroll > 2000) {
        const allAnimatedElements = document.querySelectorAll('.scroll-animate, .scroll-animate-fast, .title-animate');
        const windowHeight = window.innerHeight;
        let foundMissedElements = false;
        
        allAnimatedElements.forEach(el => {
          if (!animatedElementsSet.has(el)) {
            const rect = el.getBoundingClientRect();
            const isInViewport = rect.top < windowHeight * 0.8 && rect.bottom > 0;
            const currentOpacity = parseFloat(window.getComputedStyle(el).opacity);
            
            if (isInViewport && currentOpacity < 0.1) {
              foundMissedElements = true;
              console.log('Periodic check - found missed element:', el);
              animatedElementsSet.add(el);
              
              gsap.killTweensOf(el);
              gsap.to(el, {
                opacity: 1,
                y: 0,
                scale: 1,
                duration: 1.0,
                ease: "power1.out",
                overwrite: "auto"
              });
            }
          }
        });
        
        if (foundMissedElements) {
          console.log('Periodic check found missed elements - refreshing ScrollTrigger');
        }
      }
    }
  }, 3000); // Increased from 2000 to 3000// Mobile fallback - reduced frequency
  if (isMobile) {
    setTimeout(() => {
      checkVisibleElements();
    }, 2000); // Reduced from 3000 to 2000, and will only run once
  }
</script>
