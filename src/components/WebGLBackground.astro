---
// src/components/WebGLBackground.astro
---
<canvas id="webgl-background"></canvas>

<script>
  // Helper functions defined at the top level of the script tag
  function createShader(gl: WebGLRenderingContext, type: number, source: string): WebGLShader | undefined {
    const shader = gl.createShader(type);
    if (shader) {
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
      if (success) {
        return shader;
      }
      console.error("Shader compilation error:", gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
    }
    return undefined;
  }

  function createProgram(gl: WebGLRenderingContext, vertexShader: WebGLShader, fragmentShader: WebGLShader): WebGLProgram | undefined {
    const program = gl.createProgram();
    if (program) {
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      const success = gl.getProgramParameter(program, gl.LINK_STATUS);
      if (success) {
        return program;
      }
      console.error("Program linking error:", gl.getProgramInfoLog(program));
      gl.deleteProgram(program);
    }
    return undefined;
  }

  function resizeCanvasToDisplaySize(canvas: HTMLCanvasElement): boolean {
    const displayWidth  = canvas.clientWidth;
    const displayHeight = canvas.clientHeight;
    if (canvas.width  !== displayWidth || canvas.height !== displayHeight) {
      canvas.width  = displayWidth;
      canvas.height = displayHeight;
      return true;
    }
    return false;
  }

  function initWebGL(gl: WebGLRenderingContext, canvas: HTMLCanvasElement) {
    const vertexShaderSource = `
      attribute vec2 a_position;
      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    `;

    const fragmentShaderSource = `
      precision mediump float;
      uniform vec2 u_resolution;
      uniform float u_time;

      void main() {
        vec2 st = gl_FragCoord.xy / u_resolution.xy;
        st.x *= u_resolution.x / u_resolution.y;

        vec3 color = vec3(0.05, 0.05, 0.1);

        vec2 centerCorrectedST = st;
        if (u_resolution.x > u_resolution.y) {
          centerCorrectedST.x -= (u_resolution.x / u_resolution.y - 1.0) / 2.0;
        }

        float d = distance(centerCorrectedST, vec2(0.5 + 0.2 * sin(u_time * 0.3), 0.5 + 0.2 * cos(u_time * 0.2)));
        color += vec3(0.3 * sin(u_time * 0.5 + d * 5.0) + 0.2, 
                      0.2 * cos(u_time * 0.4 + d * 4.0) + 0.1, 
                      0.4 * sin(u_time * 0.6 + d * 6.0) + 0.3
                     ) * (1.0 - smoothstep(0.1, 0.6, d));

        float grain = (fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453) - 0.5) * 0.05;
        color += grain;
        
        gl_FragColor = vec4(color, 1.0);
      }
    `;

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

    if (!vertexShader || !fragmentShader) {
        console.error("Failed to create WebGL shaders.");
        return;
    }

    const program = createProgram(gl, vertexShader, fragmentShader);
    if (!program) {
        console.error("Failed to create WebGL program.");
        return;
    }

    const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
    const resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution");
    const timeUniformLocation = gl.getUniformLocation(program, "u_time");

    if (positionAttributeLocation === -1 || !resolutionUniformLocation || !timeUniformLocation) {
       console.error("Failed to get shader variable locations.");
       return;
    }

    const positionBuffer = gl.createBuffer();
    if (!positionBuffer) {
        console.error("Failed to create position buffer.");
        return; 
    }
    
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
    
    gl.clearColor(0, 0, 0, 0);
    gl.useProgram(program);
    gl.enableVertexAttribArray(positionAttributeLocation);
    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

    let lastTime = 0;
    function render(currentTime: number) {
        currentTime *= 0.001; 
        lastTime = currentTime;

        if (resizeCanvasToDisplaySize(canvas)) {
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        }
        
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
        gl.uniform1f(timeUniformLocation, currentTime);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(render);
    }
    
    if (resizeCanvasToDisplaySize(canvas)) {
       gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    }
    requestAnimationFrame(render);
  }

  // Main script execution
  const canvasElement = document.getElementById('webgl-background') as HTMLCanvasElement | null;
  if (canvasElement) {
    const glContext = canvasElement.getContext('webgl');
    if (glContext) {
        initWebGL(glContext, canvasElement);
    } else {
        console.error("WebGL not supported or context creation failed.");
    }
  } else {
    console.error("Canvas element #webgl-background not found.");
  }
</script>

<style>
  #webgl-background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1; 
    display: block; 
    touch-action: none; 
  }
</style>
